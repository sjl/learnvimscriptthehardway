变量
=========

到目前为止我们已经讲完了单行命令。在本书后面的三分之一个章节中将会把Vim脚本当作一个*脚本语言*。这部分东西不会像前面的你学到的东西一样马上可以学以致用，不过这是为本书的最后一部分打基础，最后一部分会讲解创建一个插件所需要的各个方面的东西。

我们开始吧。我们首先要了解的是变量。执行下面的命令。

    :::vim
    :let foo = "bar"
    :echo foo

Vim会显示`bar`。`foo`现在是一个变量，我们将一个字符串`"bar"`赋值给它。现在执行这些命令：

    :::vim
    :let foo = 42
    :echo foo

Vim会显示`42`，因为我们将`foo`赋值为整型`42`。

从这些小例子似乎可以看出Vim脚本是动态类型的。事实并非如此，我们之后会说明。

作为变量的选项
--------------------

你可以通过一种特殊语法将*选项*作为变量来设置。执行下面的命令：

    :::vim
    :set textwidth=80
    :echo &textwidth

Vim会显示`80`。在名称的前面加一个`&`符号是告诉Vim你正在引用这个选项，而不是在使用一个名称刚好相同的变量。

我们来看下Vim是怎么处理布尔选项的。执行下面的命令：

    :::vim
    :set nowrap
    :echo &wrap

Vim显示`0`。然后再试试这些选项：

    :::vim
    :set wrap
    :echo &wrap

这次Vim会显示`1`。这些输出很明确提示Vim会将整型`0`当作"false"，整型`1`当作"true"。我们可以更进一步假设Vim会将所有的非0值整型当作"truthy"，而事实确实如此。

我们也可以使用`let`命令来*设置*作为变量的选项。执行下面的命令：

    :::vim
    :let &textwidth = 100
    :set textwidth?

Vim会显示`textwidth=100`。

既然`set`可以搞定选项的设置，那我们为什么还要用`let`呢？执行下面的命令：

    :::vim
    :let &textwidth = &textwidth + 10
    :set textwidth?

这一次Vim显示`textwidth=110`。当你用`set`来设置某个选项，你只能给它设置一个常量值。当你使用`let`并将它作为一个变量来设置，你可以使用Vim脚本的所有强大之处来决定它的值。

本地选项
-------------

如果你想将某个选项作为变量来设置它的*本地*值，而不是*全局*值，你需要在变量名前面加前缀。

在两个分隔的窗口中分别打开两个文件。执行下面的命令：

    :::vim
    :let &l:number = 1

然后切换到另一文件，然后再执行下面的命令：

    :::vim
    :let &l:number = 0

注意第一个窗口会出现行号，而第二个没有。

作为变量的寄存器(Register)
----------------------

你也可以将*寄存器*当作变量来读取和设置。执行下面的命令：

    :::vim
    :let @a = "hello!"

现在把光标放到文本中的某个地方然后敲击`"ap`。这个命令会告诉Vim“在这里粘贴寄存器`a`中的内容”。我们设置了这个寄存器的内容，所以Vim会将`hello!`粘贴到你的文本中。

还可以读寄存器的内容。执行下面的命令：

    :::vim
    :echo @a

Vim会输出`hello!`。

在你的文件中选择一个单词然后用`y`复制，再执行下面的命令：

    :::vim
    :echo @"

Vim会输出你刚才复制的单词。`"`寄存器是“未命名(unnamed)”寄存器，在复制的时候没有指定寄存器的文本都会放到这里。

在你的文件中执行搜索`/someword`，然后执行下面的命令：

    :::vim
    :echo @/

Vim会输出你刚刚使用的搜索模式。这样你就可以通过编程来读*和修改*当前的搜索模式，有些时候这会很有用。

练习
---------

检查你的`~/.vimrc`文件，然后将其中的一些`set`和`setlocal`命令替换为它们的`let`形式。记住布尔选项仍然需要被设置为某个值。

尝试将某个布尔选项设置为0和1之外的值，例如`wrap`。当你将它设置为一个不同的数字时会怎么样？如果设置为字符串又会是什么情况？

回到你的`~/.vimrc`文件，然后恢复所有的修改。在`set`可以搞定的时候，永远都不要用`let`，这是因为`let`更难于阅读。

阅读`:help registers`，然后看看你可以进行读和写的寄存器列表。
